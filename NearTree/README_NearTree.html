<html>
<head>
<title>
NearTree -- function library efficiently solving the Nearest Neighbor Problem
</title>
</head>
<body>
<font face="Arial,Helvetica,Times" size="3">
<table border=2>
<tr>
<td valign="center" width="88" align="center" height="35" bgcolor="yellow">
<font face="Arial,Helvetica,Times" size="2">
<a href="http://sf.net/projects/neartree"style="text-decoration:none" >NearTree</a>
</font>
</td>
<td valign="center" width="88" align="center" height="35" bgcolor="cyan">
<font face="Arial,Helvetica,Times" size="2">
<a href="http://sf.net/projects/cvector" style="text-decoration:none">CVector</a>
</font>
</td>
<td valign="center"  width="88" align="center" height="35">
<a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=237121&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
</td>
</tr>
</table>
<hr>
<center>
<h2 align=center>NearTree</h2>
Release 2.0<br />
<font size="-1">
21 March 2009<br />
&#169; Copyright 2001, 2008, 2009 Larry Andrews.  All rights reserved
<br />
based on<br />
Larry Andrews, &quot;<i>A template for the nearest neighbor problem</i>&quot;,<br />
C/C++ Users Journal, Volume 19 ,  Issue 11  (November 2001), 40 - 49  (2001),
ISSN:1075-2838,<br />
<a href="http://www.ddj.com/architect/184401449" style="text-decoration:none">www.ddj.com/architect/184401449</a>
<p>
Revised 12 Dec 2008, for sourceforge release, Larry Andrews and Herbert J. Bernstein<br />
8 Jan 2009 Release 1.0 LCA and HJB<br />
11 Jan 2009 Release 1.0.1 LCA and HJB<br />
21 March 2009 Release 2.0 LCA and HJB
</font>
<P>

<h4>YOU MAY REDISTRIBUTE NearTree UNDER THE TERMS OF THE <a href=lgpl.txt style="text-decoration:none">LGPL</a></h4>
<p>
</center>
<center>
<table border=1>
<tr>
<td><font face="Arial,Helvetica,Times" size="2">
<h4 align=center>LGPL NOTICES</h4>
<p>
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
<p>
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU*
Lesser General Public License for more details.
<p>
You should have received a copy of the GNU Lesser General Public 
License along with this library; if not, write to the Free
Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
MA  02110-1301  USA
</td>
</table>
</center>
<P>
This is a release of an API for finding nearest neighbors among points in spaces of
arbtrary dimensions.  This release provides a C++ template, TNear.h, and a
C library, CNearTree.c, with example/test programs.
<font size="-1">
<P>This is a major update to the 1.0 release of 8 January 2009 to deal with the
following issues:
<ul>
<li>Replace use recursion with a stack, except in insertion logic
<li>Replace use of double with templated DistanceType (usually double)
<li>Provide constuctors to build NearTree from vectors, lists or sets
<li>Change &quot;Insert&quot; to &quot;insert&quot for consistentcy with
other containers
<li>Add access function &quot;at&quot; or array type references [], and provide
contents of a neartree as a vector
<li>Add iterator support
<li>Provide delayed insertion logic
<li>Functions added for searches outside of a sphere or in an annular region
</ul>
</font>
<P>
Our thanks to Nicolas Brodu for suggesting the more general handling of the
distance type.
<p>
<b>Note:</b>  As Nicolas Brodu has noted, CNearTree is paticularly well-suited
to multi-threaded applications.  However, if the same CNearTree is to be searched
in multiple threads, it is important to complete all insertions and/or delayed
insertions before parallel execution of parallel searches.
<hr>
<h4>Contents</h4>
<P>
<ul>
  <li><a href="#Installation">Installation</a>
  <li><a href="#Tnear.h">The C++ template: TNear.h</a>
  <li><a href="#CNearTree.c">The C NearTree API: CNearTree.c</a>
</ul>
<hr>
<hr>
<h4><a name="Installation">Installation</a></h4>
<p>
The NearTree package is available at <a href="http://www.sourceforge.net/projects/neartree">www.sourceforge.net/projects/neartree</a>.
A source tarball is available at <a href="http://downloads.sourceforge.net/neartree/NearTree-2.0.0.tar.gz">downloads.sourceforge.net/neartree/NearTree-2.0.0.tar.gz</a>.
Later tarballs may be available.
<P>
When the source tarball is dowloaded and unpacked, you should have a directory NearTree-2.0.0.  To see the current settings for a build
execute
<p>
make
</p>
which should give the following information:
<p>
<pre><tt>
 PLEASE READ README_NearTree.txt and lgpl.txt
 
 Before making the NearTree libraries and example programs, check
 that the chosen settings are correct
 
 The current C++ and C compile commands are:
 
   libtool --mode=compile g++ -g -O2  -Wall -ansi -pedantic  \
      -DCNEARTREE_SAFE_TRIANG=1 -I.   -c
   libtool --mode=compile gcc -g -O2  -Wall -ansi -pedantic  \
      -DCNEARTREE_SAFE_TRIANG=1 -I.   -c
 
 The C API, CNearTree.c, depends on the sourceforge project CVector 
 You are currently setup to use the system defaults for CVector
 If that is not correct, define the variable CVECTOR_INCLUDE 

 The current library link command is:
 
   libtool --mode=link  gcc -version-info 2:0:2 -release 2.0.0 \
     -no-undefined -rpath /usr/local/lib
 
 The current C++ and C library local, and C dynamic and static build commands are:
 
   libtool --mode=link g++ -no-undefined -g -O2  -Wall -ansi -pedantic \
      -DCNEARTREE_SAFE_TRIANG=1 -I. 
   libtool --mode=link gcc -g -O2  -Wall -ansi -pedantic \
      -DCNEARTREE_SAFE_TRIANG=1 -I. 
   libtool --mode=link gcc -no-undefined -g -O2  -Wall -ansi -pedantic \
      -DCNEARTREE_SAFE_TRIANG=1 -shared -I/usr/local/include
   libtool --mode=link gcc -g -O2  -Wall -ansi -pedantic  \
      -DCNEARTREE_SAFE_TRIANG=1 -static-libtool-libs -I/usr/local/include
 
 Before installing the NearTree library and example programs, check
 that the install directory and install commands are correct:
 
 The current values are :
 
   /usr/local 
   libtool --mode=install cp 
    
 
 To compile the NearTree library and example programs type:
 
   make clean
   make all
 
 To run a set of tests type:
 
   make tests
 
 To clean up the directories type:
 
   make clean
 
 To install the library and headers type:
 
   make install

</tt>
</pre>
<p>
If these settings need to be changed, edit Makefile.  On some systems, e.g. Mac OS X, the default
libtool is not appropriate.  In that case you should install a recent version of libtool.  The
CVector kit has been tested with libtool versions 1.3.5 and 1.5.4.  For MINGW, libtool version 2.2.6
and gcc version 4 are needed to work with shared libraries (DLLs).   If the system libtool is
not to be used, define the variable LIBTOOL to be the path to the libtool executable, e.g.
in bash
<p>
export LIBTOOL=$HOME/bin/libtool
<p>
or in the Makefie
<p>
LIBTOOL = $(HOME)/bin/libtool
<p>
If you need to include local header files using #include &quot;...&quot; instead of #include &lt;...&gt;,
define the variable USE_LOCAL_HEADERS
<p>
There is an optimization error in some compilers that miscompiles the triangle
inequality.  The default in this API is to do the triangle inequality three
different ways under the control of CNEARTREE_SAFE_TRIANG
<p>
<pre><tt>
#ifdef CNEARTREE_SAFE_TRIANG
#define TRIANG(a,b,c) (  (((b)+(c))-(a) >= 0) \
                      || ((b)-((a)-(c)) >= 0) \
                      || ((c)-((a)-(b)) >= 0))    
#else
#define TRIANG(a,b,c) (  (((b)+(c))-(a) >= 0))
#endif
</tt></pre>
<p>
Problems with the unsafe definition of TRIANG have been seen in Linux under gcc version 4
and in MS Window under VS 2003.  There is a slight performance hit from the triple test.
If maximal speed is critical and misidentification of nearest points by relative distance
errors of about 1 part in 10**15 is not a serious problem, the definition of 
-DCNEARTREE_SAFE_TRIANG=1 can be removed from the definition of CFLAGS in the Makefile.

<hr>
<hr>
<h4><a name="Tnear.h">The C++ template: TNear.h</a></h4>
<P>
This is a revised release of
<blockquote>
template &lt;typename T, typename DistanceType=double, int distMinValue=-1 &gt; class CNearTree;
</blockquote>
<P>
implementing the Nearest Neighbor algorithm after Kalantari and McDonald,
(IEEE Transactions on Software Engineering, v. SE-9, pp.   631-634,1983)
modified to use recursion instead of a double-linked tree
and simplified so that it does a bit less checking for
things like is the distance to the right less than the
distance to the left; it was found that these checks made little
to no difference.
<p>
CNearTree is the root class for the neartree. The actual data of the
tree is stored in NearTreeNode objects descending from a CNearTree.
<p>
The types of objects that can be stored in the tree is quite broad. The 
biggest limitation is that the objects must reside in some sort of metric
space and must obey the triangle rule. They must also be all of the same
size because they are stored in an std::vector. If your application
requires object of varying storage, then your best way to use this
code is to store pointers or handles and to write your own distance functions.
<p>
The type of the objects to be stored is the only <b>required</b> template argument.
The type of the distance measure (DistanceType) defaults to double. If your 
application is for an integer type then the type for DistanceType can be your 
integer type. This has the potential for speeding the calculations by
avoiding FP computation. Other general types can be used if desired, but you
may need to also input a value of distMinValue.
<p>
The template argument distMinValue must be something that your class will
understand as a negative number. The default input is negative one. Internally,
that is cast to DistanceType. Since most uses will be for DistanceType
to be double, that is a simple conversion. Obviously, for integer types,
there is no problem either. The need for this value is to have something
internally that is recognizable as smaller than the smallest "distance"
that can exist between any two objects in your type. For most users,
there is no need to input anything other than the default, -1. -1 must 
be castable to DistanceType. It seems unlikely that anyone would actually
need this optional parameter, but it is here for completeness.
<p>
It is a design decision that this class cannot work for unsigned types.
It is hard to see how to verify the triangle rule for unsigned types,
and distance computations become more complex. Sorry, unsigned types
are left as an exercise for the reader.

<p>

The user of this class needs to provide at least the following
functionality for the template to work. For the built-in
numerics of C++, they are provided by the system.
<p>
<center>
<table>
<tr>
<td><font face="Arial,Helvetica,Times" size="3">
 DistanceType Norm( );   </font></td><td><font face="Arial,Helvetica,Times" size="3">// conversion constructor from the templated class to DistanceType<br />
// (usually will return a "length" of type double)
</font></td>
</tr>
<tr>
<td><font face="Arial,Helvetica,Times" size="3">
operator- ( );         </font></td><td><font face="Arial,Helvetica,Times" size="3">// geometrical (vector) difference of two objects
</font></td>
</tr>
<tr>
<td></td><td><font face="Arial,Helvetica,Times" size="3">//    a copy constructor would be nice
</font></td>
</tr>
<tr>
<td></td><td><font face="Arial,Helvetica,Times" size="3">//    a constructor would be nice
</font></td>
</tr>
<tr>
<td></td><td><font face="Arial,Helvetica,Times" size="3">//    a destructor would be nice
</font></td>
</tr>
</table>
</center>
<p>
The provided interface is:
<p>
<pre><tt>
    <b>#include &lt;TNear.h&gt;</b>

    <b>CNearTree</b>( <b>void</b> )   // constructor
       instantiated by something like:      CNearTree &lt;T&gt; vTree;
       for some type T
       
    <b>CNearTree</b>( <b>const std::vector&lt;T&gt;</b> )   // constructor
    <b>CNearTree</b>( <b>const std::list&lt;T&gt;</b> )     // constructor
    <b>CNearTree</b>( <b>const std::set&lt;T&gt;</b> )      // constructor
    
    <b>~CNearTree</b>( <b>void</b> )  // destructor

    <b>void Insert</b>( <b>const T&amp;</b> <i>t</i> )
       where t is an object of the type v

    <b>void insert</b>( <b>const std::vector&lt;T&gt;</b> )
    <b>void insert</b>( <b>const std::list&lt;T&gt;</b> )
    <b>void insert</b>( <b>const std::set&lt;T&gt;</b> ) 

    <b>bool NearestNeighbor</b> ( <b>const DistanceType&amp;</b> <i>dRadius</i>,  <b>T&amp;</b> <i>tClosest</i>,   <b>const T&amp;</b> <i>t</i> ) <b>const</b>
       <i>dRadius</i> is the largest radius within which to search; make it
          very large if you want to include every point that was loaded.
          dRadius is returned as the closest distance to the probe (or the search radius
          if nothing is found)
       <i>tClosest</i> is returned as the object that was found closest to the probe
          point (if any were within radius dRadius of the probe)
       <i>t</i> is the probe point, used to search in the group of points insert'ed

       return value is true if some object was found within the search radius, false otherwise.
          If false is returned, tClosest is invalid (at best).

    <b>iterator NearestNeighbor</b> ( <b>const DistanceType &amp;</b> <i>dRadius</i>, <b>const T&amp;</b> <i>t</i> ) <b>const</b>
       returns an iterator to the nearest point to the probe point <i>t</i> or end() if there is none

    <b>bool FarthestNeighbor</b> ( <b>T&amp;</b> <i>tFarthest</i>,   <b>const T&amp;</b> <i>t</i> ) <b>const</b>
       <i>tFarthest</i> is returned as the object that was found farthest to the probe
          point
       <i>t</i> is the probe point, used to search in the group of points Insert'ed
       return value is true if some object was found, false otherwise
          If false is returned, tFarthest is invalid (at best).

    <b>iterator FarthestNeighbor</b> ( <b>T&amp;</b> <b>const T&amp;</b> <i>t</i> ) <b>const</b>
       returns an iterator to the nearest point to the probe point<i>t</i> or end() if there is none

    <b>long FindInSphere</b> ( <b>const DistanceType&amp;</b> <i>dRadius</i>,  <b>std::vector&lt;  T &gt;&amp;</b> <i>tInside</i>,   <b>const T&amp;</b> t ) <b>const</b>
       <i>dRadius</i> is the radius within which to search; make it very large if you want to
           include every point that was loaded;
       <i>tInside</i> is returned as the vector of objects that were found within a radius dRadius
          of the probe point
       <i>t</i> is the probe point, used to search in the group of points Insert'ed

       return value is the count of the number of points found within the search radius

    <b>long FindInSphere</b> ( <b>const DistanceType&amp;</b> <i>dRadius</i>,  <b>CNearTree&lt;  T &gt;&amp;</b> <i>tInside</i>,   <b>const T&amp;</b> t ) <b>const</b>
       <i>dRadius</i> is the radius within which to search; make it very large if you want to
           include every point that was loaded;
       <i>tInside</i> is returned as the CNearTree of objects that were found within a radius dRadius
          of the probe point
       <i>t</i> is the probe point, used to search in the group of points Insert'ed

       return value is the count of the number of points found within the search radius

    <b>long FindOutSphere</b> ( <b>const DistanceType&amp;</b> <i>dRadius</i>,  <b>std::vector&lt;  T &gt;&amp;</b> <i>tOutside</i>,   <b>const T&amp;</b> t ) <b>const</b>
       <i>dRadius</i> is the radius outside of which to search
       <i>tOutside</i> is returned as the vector of objects that were found at or outside of radius dRadius
          of the probe point
       <i>t</i> is the probe point, used to search in the group of points Insert'ed

       return value is the count of the number of points found within the search radius

    <b>long FindOutSphere</b> ( <b>const DistanceType&amp;</b> <i>dRadius</i>,  <b>CNearTree&lt;  T &gt;&amp;</b> <i>tOutside</i>,   <b>const T&amp;</b> t ) <b>const</b>
       <i>dRadius</i> is the radius outside of which to search.
       <i>tClosest</i> is returned as the CNearTree of objects that were found at or outside of a radius dRadius
          of the probe point
       <i>t</i> is the probe point, used to search in the group of points Insert'ed

       return value is the count of the number of points found within the search radius
    
    <b>long FindInAnnulus</b> ( <b>const DistanceType&amp;</b> <i>dRadius1</i>, <b>const DistanceType&amp;</b> <i>dRadius2</i>, <b>std::vector&lt;  T &gt;&amp;</b> <i>tInRing</i>,   <b>const T&amp;</b> t ) <b>const</b>
       <i>dRadius1</i> and  <i>dRadius2</i> are the two radii between which to find data points
       <i>tInRing</i> is returned as the vector of objects that were found at or outside of a radius dRadius1
          and at or inside of radius dRadius2 of the probe point
       <i>t</i> is the probe point, used to search in the group of points Insert'ed

       return value is the count of the number of points found within the annulus

    <b>long FindInAnnulus</b> ( <b>const DistanceType&amp;</b> <i>dRadius1</i>, <b>const DistanceType&amp;</b> <i>dRadius2</i>,  <b>CNearTree&lt;  T &gt;&amp;</b> <i>tInRing</i>,   <b>const T&amp;</b> t ) <b>const</b>
       <i>dRadius1</i> and  <i>dRadius2</i> are the two radii between which to find data points
       <i>tInRing</i> is returned as the CNearTree of objects that were found at or outside of a radius dRadius1
          and at or inside of radius dRadius2 of the probe point
       <i>t</i> is the probe point, used to search in the group of points Insert'ed

       return value is the count of the number of points found within the annulus
    
<hr>

Access Functions:

     <b>T at</b> ( <b>const size_t</b> <i>n</i> ) <b>const</b>
        returns the n'th item of the internal data store

     <b>T operator[]</b> ( <b>const size_t</b> <i>n</i> )
        returns the n'th item of the internal data store

     <b>operator std::vector&lt;T&gt;</b> ( <b>void</b> ) <b>const</b> 
        returns all of the inserted objects in the tree in a vector. 
         The returned vector contents are not guaranteed to be returned in the order loaded.

     <b>iterator begin</b> ( <b>void</b> ) <b>const</b> 
        returns an iterator to the beginning of the internal data store

     <b>iterator end</b> ( <b>void</b> ) <b>const</b> 
        returns an iterator to the end of the data store (one beyond the last item)

     <b>iterator back</b> ( <b>void</b> ) <b>const</b>
        returns an iterator to the last data item of the internal data store

<hr>

Information and special operation functions:

     <b>void DelayedInsert</b> ( <b>const T&amp;</b> <i>t</i> ) 
        places objects in a queue for insertion later when CompleteDelayInsert
        is called or a search is called. The purpose is to distribute the objects a bit more 
        randomly. Excessively ordered objects leads to less than optimal trees.

     <b>void CompleteDelayedInsert</b> ( <b>void</b> ) 
        calls insert for all delayed objects. sqrt(n) of them are inserted by random choice. 
        The rest are inserted in linear order as originally queued. CompleteDelayedInsert
        is invoked at the beginning of all searches, so the average user will never need
        to call it.

     <b>size_t GetDeferredSize</b> ( <b>void</b> ) 
        returns the number of delayed objects that have not yet been insert'ed. This is 
        mainly for information about details of the tree.

     <b>size_t GetTotalSize</b> ( <b>void</b> )
        returns the number of objects that have been insert'ed plus those DelayInsert'ed

     <b>size_t size</b> ( <b>void</b> ) 
        identical to GetTotalSize

     <b>size_t GetDepth</b> ( <b>void</b> ) 
        returns the maximum tree layers from the root.  This is mainly for information about 
        details of the tree.

     <b>bool empty</b> ( <b>void</b> )
        returns true if the tree is empty, otherwise false
        
<hr>

Iterators:

     Random access iterators are provided for accessing the data in a CNearTree. The most important
     expected use is to retrieve the objects returned from one of the sphere search functions that
     return a CNearTree. However, they can be used with any CNearTree.
     
     They should function in a fashion essentially the same as STL iterators. There is no assurance
     that data will be returned in the order it was loaded, just that it is accessible.

     <b>iterator</b> ( <b>void</b> ) { }; // constructor

     <b>iterator& operator=  </b> ( <b>const iterator&amp;</b> <i>s</i> )      
     <b>iterator  operator++ </b> ( <b>const int</b> <i>n</i> )            
     <b>iterator  operator-- </b> ( <b>const int</b> <i>n</i> )            
     <b>iterator& operator++ </b> ( <b>void</b> )                   
     <b>iterator& operator-- </b> ( <b>void</b> )                   
     <b>iterator  operator+  </b> ( <b>const long</b> <i>n</i> ) <b>const</b>     
     <b>iterator  operator-  </b> ( <b>const long</b> <i>n</i> ) <b>const</b>     
     <b>iterator& operator+= </b> ( <b>const long</b> <i>n</i> )           
     <b>iterator& operator-= </b> ( <b>const long</b> <i>n</i> )           
     <b>T         operator*  </b> ( <b>void</b> )        <b>const</b>     

     <b>bool      operator== </b> ( <b>const iterator&amp</b> <i>t</i> ) <b>const</b> 
     <b>bool      operator!= </b> ( <b>const iterator&</b> <i>t</i> ) <b>const</b> 

     <b>const T * const operator-> </b> ( <b>void</b> )   <b>const</b>

<hr>
  </tt>
</pre>
<p>
So a complete program is:
<p>
<pre>
<tt>
 #include "TNear.h"
 #include &lt;cstdio&gt;
 void main()
 {
   CNearTree&lt; double &gt; dT;
   double dNear;
   dT.Insert( 1.5 );
   if ( dT.NearestNeighbor( 10000.0,   dNear,  2.0 )) printf( "%f\n",double(dNear-2.0) );
 }
</tt>
</pre>
   
 and it should print 0.5 (that's how for 2.0 is from 1.5).  For more examples of
 the use of TNear.h, see <a href="main.cpp">main.cpp</a> and <a href="CNearTreeTest.cpp">CNearTreeTest.cpp</a>.

<hr>
<hr>
<h4><a name="CNearTree.c">The C NearTree API: CNearTree.c</a></h4>
<h4>Synopsis</h4>
<P>
<blockquote>
<font size="-1">
<b>#include &lt;CNearTree.h&gt;</b>
<P>
<p>   
     <b>double</b> <b>CNearTreeDist</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, <b>void *</b> <i>coord1</i>,
                           <b>void *</b> <i>coord2</i> );
<p>
     <b>int</b> <b>CNearTreeSetNorm</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, <b>int</b> <i>treenorm</i> );
                                                 
<p>
     <b>int</b> <b>CNearTreeNodeCreate</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>,  
                               <b>CNearTreeNodeHandle *</b> <i>treenodehandle</i> )     

<p> 
     <b>int</b> <b>CNearTreeCreate</b> ( <b>CNearTreeHandle *</b> <i>treehandle</i>, 
                        <b>size_t</b> <i>treedim</i>, 
                        <b>int</b> <i>treetype</i> );
<p>    
    <b>int</b> <b>CNearTreeFree</b> ( <b>CNearTreeHandle</b> <i>treehandle</i> );
 
<p>    
    <b>int</b> <b>CNearTreeClear</b> ( <b>CNearTreeHandle *</b> <i>treehandle</i> );
 
<p>
    <b>int</b> <b>CNearTreeNodeFree</b> ( <b>CNearTreeNodeHandle *</b> <i>treenodehandle</i> );    

<p>
 
    <b>int</b> <b>CNearTreeInsert</b>( <b>CNearTreeHandle</b> <i>treehandle</i>,
                        <b>const</b> <b>void *</b> <i>coord</i>, 
                        <b>const</b> <b>void *</b> <i>obj</i> );
<p>
    <b>int</b> <b>CNearTreeNodeInsert</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>,
                        <b>CNearTreeNodeHandle</b> <i>treenodehandle</i>, 
                        <b>size_t</b> <i>index</i>;
                        <b>size_t *</b> <i>depth</i> );
<p>
    <b>int</b> <b>CNearTreeDelayedInsert</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>,
                        <b>const</b> <b>void *</b> <i>coord</i>, 
                        <b>const</b> <b>void *</b> <i>obj</i> );
<p>
    <b>int</b> <b>CNearTreeCompleteDelayedInsert</b> ( <b>CNearTreeHandle</b> <i>treehandle</i> )

    
    <b>int</b> <b>CNearTreeZeroIfEmpty</b> ( <b>CNearTreeHandle</b> <i>treehandle</i> );
<p>
 
    <b>int</b> <b>CNearTreeGetSize</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, <b>size_t *</b> <i>size</i> );
    
<p>
    <b>int</b> <b>CNearTreeGetDelayedSize</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, <b>size_t *</b> <i>size</i> );
<p>
    <b>int</b> <b>CNearTreeGetDepth</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, <b>size_t *</b> <i>depth</i> )
    
<p>     
    <b>int</b> <b>CNearTreeNearestNeighbor</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, 
                                  <b>const</b> <b>double</b> dRadius,  
                                  <b>void * *</b> <i>coordClosest</i>,
                                  <b>void * *</b>  <i>objClosest</i>, 
                                  <b>const</b> <b>void *</b> <i>coord</i> );
<p>     
    <b>int</b> <b>CNearTreeFarthestNeighbor</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, 
                                   <b>void *</b> * <i>coordFarthest</i>,
                                   <b>void *</b> * <i>objFarthest</i>,   
                                   <b>const</b> <b>void *</b> <i>coord</i> );
<p>          
    <b>int</b> <b>CNearTreeFindInSphere</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>,
                               <b>const</b> <b>double</b> <i>dRadius</i>,
                               <b>CVectorHandle</b> <i>coordInside</i>,
                               <b>CVectorHandle</b> <i>objInside</i>,
                               <b>const</b> <b>void *</b> <i>coord</i>,
                               <b>int</b> <i>resetcount</i> );
<p>                               
    <b>int</b> <b>CNearTreeFindTreeInSphere</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>,
                               <b>const</b> <b>double</b> <i>dRadius</i>,
                               <b>CNearTreeHandle</b> <i>foundInside</i>,
                               <b>const void *</b> <i>coord</i>,
                               <b>int</b> <i>resetcount</i> )
<p>          
    <b>int</b> <b>CNearTreeFindOutSphere</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>,
                               <b>const</b> <b>double</b> <i>dRadius</i>,
                               <b>CVectorHandle</b> <i>coordOutside</i>,
                               <b>CVectorHandle</b> <i>objOutside</i>,
                               <b>const</b> <b>void *</b> <i>coord</i>,
                               <b>int</b> <i>resetcount</i> );
<p>                               
    <b>int</b> <b>CNearTreeFindTreeOutSphere</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>,
                               <b>const</b> <b>double</b> <i>dRadius</i>,
                               <b>CNearTreeHandle</b> <i>foundOutside</i>,
                               <b>const void *</b> <i>coord</i>,
                               <b>int</b> <i>resetcount</i> )
<p>          
    <b>int</b> <b>CNearTreeFindInAnnulus</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>,
                               <b>const</b> <b>double</b> <i>dRadiusInner</i>,
                               <b>const</b> <b>double</b> <i>dRadiusOuter</i>,
                               <b>CVectorHandle</b> <i>coordInRing</i>,
                               <b>CVectorHandle</b> <i>objInRing</i>,
                               <b>const</b> <b>void *</b> <i>coord</i>,
                               <b>int</b> <i>resetcount</i> );
<p>                               
    <b>int</b> <b>CNearTreeFindTreeInAnnulus</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>,
                               <b>const</b> <b>double</b> <i>dRadiusInner</i>,
                               <b>const</b> <b>double</b> <i>dRadiusOuter</i>,
                               <b>CNearTreeHandle</b> <i>foundInRing</i>,
                               <b>const void *</b> <i>coord</i>,
                               <b>int</b> <i>resetcount</i> )
<p> 
    <b>int</b> <b>CNearTreeNearest</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, 
                          <b>double</b> * dRadius,  
                          <b>void *</b> * <i>coordClosest</i>,
                          <b>void *</b> * <i>objClosest</i>,
                          <b>const</b> <b>void *</b> <i>coord</i> );
<p>     
    <b>int</b> <b>CNearTreeFindFarthest</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>,
                               <b>double</b> * dRadius,  
                               <b>void *</b> * <i>coordFarthest</i>,
                               <b>void *</b> * <i>objFarthest</i>,
                               <b>const</b> <b>void *</b> <i>coord</i> );
<p>
    <b>int</b> <b>CNearTreeObjects</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, <b>CVectorHandle *</b> <i>vectorhandle</i> );
<p>
    <b>void *</b> <b>CNearTreeObjectAt</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, <b>size_t</b> <i>index</i> );
<p>
    <b>int</b> <b>CNearTreeCoords</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, <b>CVectorHandle *</b> <i>vectorhandle</i> );
<p>
    <b>void *</b> <b>CNearTreeCoordAt</b> ( <b>CNearTreeHandle</b> <i>treehandle</i>, <b>size_t</b> <i>index</i> );
</font>
</blockquote>
<p>    

The NearTree API works with coordinate vectors in an arbitrary number of
dimensions.  Each neartree is accessed by a pointer of type <b>CNearTreeHandle</b>
which points to a struct of type <b>CNearTree</b>, which points to a tree of
nodes of type CNearTreeNode:
<p>
<pre><tt>
    typedef struct _CNearTreeNode {
        size_t           m_indexLeft;    /* index of left coords in m_CoordStore  
                                            and of left object in m_ObjectStore     */
        size_t           m_indexRight;   /* index of right coords in m_CoordStore 
                                            and of right object in m_ObjectStore     */
        double           m_dMaxLeft;     /* longest distance from the left object
                                            to anything below it in the tree            */
        double           m_dMaxRight;    /* longest distance from the right object 
                                            to anything below it in the tree            */
        struct _CNearTreeNode * m_pLeftBranch;  
                                         /* tree descending from the left object        */
        struct _CNearTreeNode * m_pRightBranch; 
                                         /* tree descending from the right object       */
        int              m_iflags;       /* flags                                       */
    } CNearTreeNode;
    
    
    typedef CNearTreeNode * CNearTreeNodeHandle;   
    
    typedef struct {
        CNearTreeNodeHandle m_ptTree;     /* pointer to the actual tree                  */
        size_t           m_szdimension;   /* dimension of the coordinates                */
        size_t           m_szsize;        /* size of this tree                           */
        size_t           m_szdepth;       /* depth of this tree                          */
        int              m_iflags;        /* flags                                       */
        CVectorHandle    m_ObjectStore;   /* all inserted objects                        */
        CVectorHandle    m_CoordStore;    /* all inserted coordinates                    */
        CVectorHandle    m_DelayedIndices;/* objects queued for insertion                */
    } CNearTree;
    
    typedef CNearTree     FAR * CNearTreeHandle;

</pre></tt>
</p>
The internal operation of the API depends on the function <b>CNearTreeDist</b> 
that returns the distance (L1, L2 or L-infinity)  between two 
coordinate vectors as a double according to the parameters of the given tree.
Note that the tree may store the coordinates as integers or as doubles, but
the distance is always computed as a double.
If this function is replaced by a user function, it is important that the
replacement obey the triangle inequality.
<P>
A neartree is created by  <b>CNearTreeCreate</b> and freed by <b>CNearTreeFree</b>.
<i>treedim</i> is the dimension of the coordinate vectors and <i>treetype</i>
is one of the two predefined constants <b>CNEARTREE_TYPE_DOUBLE</b> for double
or <b>CNEARTREE_TYPE_INTEGER</b> for integer, optionally ORed with CNEARTREE_NORM_L1,
CNEARTREE_NORM_L2 or CNEARTREE_NORM_LINF for L1, L2 or L-infinity norms.  If
it is desired to automatically defer all inserts until a the first search or
a manual call to <b>CNearTreeCompleteDelayedInsert</b>, the flag CNEARTREE_DEFER_ALL
should be ored with <i>treetype</i>.  Alteratively, if minimal reorganization of
the order of the tree is desired on each insertion, <b>CNEARTREE_FLIP</b> should
be ored with <i>treetype</i>.
When first created, a neartree has no right or left node and with the dMax-below
set to negative values so that any match found will be stored since it will
greater than the negative value.  The tree is then populated by calls to
<b>CNearTreeInsert</b>, with each call providing a coordinate vector <i>coord</i>
and an optional object pointer <i>obj</i>.  The API copies the coordinate vector,
but does not copy the object.  The tree is populated in the order left, right
and then the nearer child.
<p>
Optionally, the actual insertions may be delayed and then completed in the first search
or in an explicit <b>CNearTreeCompleteDelayedInsert</b> call.
<p>
The neartree is searched for the nearest or farthest coordinate vector in the neartree to a given
probe coordinate vector <i>coord</i> by <b>CNearTreeNearestNeighbor</b> and 
<b>CNearTreeFarthestNeighbor</b>, respectively.  The given radius confines the search
to a sphere around the probe.  If more than a single extremal coordinate point is
needed, <b>CNearTreeFindInSphere</b> can be used to obtain a CVector result vector of 
all the coordinate vectors that satisfy the constraint of being within a specified
radius, or <b>CNearTreeFindOutSphere</b> can be used to obtain a CVector result vector
of all the coordinates that satisfy the constraint of being outside a specified radius.
<b>CNearTreeFindIn Annulus</b> can be used to obtain a CVector result vector of all the
coordinates that satisfy the constraint of being between two specified radii from the probe.
The vectors themselves
are not copied into the result vector.  If the parameter <i>resetcount</i> is true (non
zero) the result vector is cleared before the search.   A parallel CVector result vector
of the matching object pointers is returned if <i>objs</i> is not NULL. 
Aternatives the forms <b>CNearTreeFindTreeInSphere</b>, <b>CNearTreeFindTreeOutSphere</b>,
<b>CNearTreeFindTreeInAnnulus</b> can be used to obtain CNearTrees rather than CVectors of
results.  The functions
<b>CNearTreeNearest</b> and <b>CNearTreeFindFarthest</b> implement <b>CNearTreeNearestNeighbor</b> and 
<b>CNearTreeFarthestNeighbor</b>, respectively, adjusting the radius of the search while
the search is in progress, and are not normally used by users
<P>
<h4>Returns</h4>
If <b>CNearTreeDist</b> fails, it returns -1.  Except for <b>CNearTreeDist</b>, all the functions 
in the API return 0 ( <b>CNEARTREE_SUCCESS</b> ) for
success.    If dynamic memory allocation fails, <b>CNEARTREE_MALLOC_FAILED</b> is returned.
If a call is made with an improper argument, <b>CNEARTREE_BAD_ARGUMENT</b> is returned.
If a search fails to find anything, <b>CNEARTREE_NOT_FOUND</b> is returned.  If there is
a failure in an attempt to free a CNearTree, <b>CNEARTREE_FREE_FAILED</b> is returned.  If
any of the internal call to CVector fail, <b>CNEARTREE_CVECTOR_FAILED</b> is returned.  For
convenience in debugging, the formerly negative values of this returns are now positive.
<p>
<h4>Examples</h4>
<P>
To create a neartree for 3-dimensional vectors of doubles:
<P>
<pre>
<tt> 
#include <CNearTree.h>
CNearTreeHandle treehandle;
int bReturn;
 
 ...
 
 bReturn = !CNearTreeCreate(&treehandle,3,CNEARTREE_TYPE_DOUBLE);
</tt>
</pre>
<p>
 
To insert a copy of a 3-dimensional vector of doubles into this tree,
with no associated object:
<P>
<pre>
<tt> 
    double v[3];
 
 ...
     
    v[0] = 1.; v[1] = 2.; v[2] = 3.;
    bReturn = !CNearTreeInsert(treehandle,&amp;v[0],NULL);
</tt>
</pre>
<p>
To search for the nearest neighbor to a probe vector vSearch in a radius of 3.,
returning a pointer to the resulting vector in vBest:
<P>
<pre>
<tt> 
    double * vBest;
    void * vvBest;
    double vSearch[3];
    double   dRad = =3.;
    
  ...
  
    if ( !CNearTreeNearestNeighbor(treehandle,dRad,&amp;vvBest,NULL,vSearch))
        {   vBest = (double *)vvBest; }
</tt>
</pre>
<p>
Note the use of a separate void * vvBest instead of a cast of &amp;vBest to avoid compiler 
type punning warnings.
<P>
For more examples of the use of CNearTree.c, see <a href="main.c">main.c</a> and <a href="CNearTreeTest.c">CNearTreeTest.c</a>
in the release kit.
<hr>
<hr>
<font size="-1">
Updated 21 Mar 2009<br />
<script language="javascript" type="text/javascript">
<!-- 
      var name = "yaya@";
      var domain = "bernstein-plus-sons";
      var domext = ".com";
      document.write ("<a href=\"mailto:" + name + domain + domext + "\">" + name + domain + domext+"</a>"); 
// -->
</script>
<noscript>
yaya&#64;bernstein-plus-sons&#46;com
</noscript>
</font>
</font>
</body>
</html>
